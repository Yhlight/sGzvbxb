#ifndef CHTL_CONTEXT_H
#define CHTL_CONTEXT_H

#include <string>
#include <memory>
#include <unordered_map>
#include <vector>
#include <stack>
#include <optional>
#include "CHTLStateMachine.h"

namespace chtl {

// 前向声明
class TemplateDefinition;
class CustomDefinition;
class VariableDefinition;
class ElementDefinition;
class StyleDefinition;
class NamespaceDefinition;

// 符号类型
enum class SymbolType {
    ELEMENT,
    STYLE,
    VARIABLE,
    TEMPLATE_STYLE,
    TEMPLATE_ELEMENT,
    TEMPLATE_VAR,
    CUSTOM_STYLE,
    CUSTOM_ELEMENT,
    CUSTOM_VAR,
    NAMESPACE,
    IMPORTED,
    CONFIGURATION
};

// 基础符号信息
struct Symbol {
    std::string name;
    SymbolType type;
    std::string namespace_path;
    std::string source_file;
    int line_number;
    bool is_exported;
    std::shared_ptr<void> definition;  // 指向具体的定义
    
    Symbol(const std::string& n, SymbolType t) 
        : name(n), type(t), line_number(0), is_exported(false) {}
};

// 作用域类型
enum class ScopeType {
    GLOBAL,
    NAMESPACE,
    TEMPLATE,
    CUSTOM,
    ELEMENT,
    STYLE,
    CONFIGURATION
};

// 作用域
class Scope {
private:
    ScopeType type;
    std::string name;
    std::shared_ptr<Scope> parent;
    std::unordered_map<std::string, std::shared_ptr<Symbol>> symbols;
    std::vector<std::string> constraints;  // except约束
    
public:
    Scope(ScopeType t, const std::string& n, std::shared_ptr<Scope> p = nullptr)
        : type(t), name(n), parent(p) {}
    
    // 符号管理
    bool addSymbol(std::shared_ptr<Symbol> symbol);
    std::shared_ptr<Symbol> lookupSymbol(const std::string& name);
    std::shared_ptr<Symbol> lookupSymbolRecursive(const std::string& name);
    
    // 约束管理
    void addConstraint(const std::string& constraint);
    bool isAllowed(const std::string& feature) const;
    
    // 获取器
    ScopeType getType() const { return type; }
    const std::string& getName() const { return name; }
    std::shared_ptr<Scope> getParent() const { return parent; }
};

// 配置项
struct Configuration {
    std::string defaultEncoding = "UTF-8";
    std::string defaultOutput = "output.html";
    bool generateSourceMap = false;
    bool minifyOutput = false;
    int optimizationLevel = 1;
    
    // 原有配置项
    int index_initial_count = 0;
    bool disable_name_group = false;
    bool debug_mode = false;
    std::unordered_map<std::string, std::vector<std::string>> name_mappings;
    int option_count = 3;
};

// CHTL上下文
class CHTLContext {
private:
    // 状态机
    std::unique_ptr<CHTLStateMachine> stateMachine;
    
    // 作用域栈
    std::stack<std::shared_ptr<Scope>> scopeStack;
    std::shared_ptr<Scope> globalScope;
    
    // 符号表（全局快速查找）
    std::unordered_map<std::string, std::shared_ptr<Symbol>> globalSymbols;
    
    // 模板定义
    std::unordered_map<std::string, std::shared_ptr<TemplateDefinition>> templates;
    
    // 自定义定义
    std::unordered_map<std::string, std::shared_ptr<CustomDefinition>> customs;
    
    // 命名空间
    std::unordered_map<std::string, std::shared_ptr<NamespaceDefinition>> namespaces;
    std::string currentNamespace;
    
    // 导入的模块
    std::unordered_map<std::string, std::string> imports;  // alias -> path
    
    // 配置
    Configuration config;
    
    // 当前处理的文件信息
    std::string currentFile;
    int currentLine;
    
    // 自动生成的类名/ID追踪
    std::unordered_map<std::string, int> autoGeneratedNames;
    
public:
    CHTLContext();
    ~CHTLContext() = default;
    
    // 状态机访问
    CHTLStateMachine& getStateMachine() { return *stateMachine; }
    
    // 作用域管理
    void pushScope(ScopeType type, const std::string& name);
    void popScope();
    std::shared_ptr<Scope> getCurrentScope() const;
    
    // 符号管理
    bool registerSymbol(const std::string& name, SymbolType type, std::shared_ptr<void> definition = nullptr);
    std::shared_ptr<Symbol> lookupSymbol(const std::string& name);
    std::shared_ptr<Symbol> lookupSymbolWithNamespace(const std::string& name, const std::string& ns);
    
    // 模板管理
    bool registerTemplate(const std::string& type, const std::string& name, std::shared_ptr<TemplateDefinition> def);
    std::shared_ptr<TemplateDefinition> getTemplate(const std::string& type, const std::string& name);
    
    // 自定义管理
    bool registerCustom(const std::string& type, const std::string& name, std::shared_ptr<CustomDefinition> def);
    std::shared_ptr<CustomDefinition> getCustom(const std::string& type, const std::string& name);
    
    // 命名空间管理
    void enterNamespace(const std::string& name);
    void exitNamespace();
    std::string getCurrentNamespace() const { return currentNamespace; }
    std::string getFullQualifiedName(const std::string& name) const;
    
    // 导入管理
    void addImport(const std::string& path, const std::string& alias = "");
    bool isImported(const std::string& name) const;
    
    // 配置管理
    Configuration& getConfig() { return config; }
    const Configuration& getConfig() const { return config; }
    void setConfigValue(const std::string& key, const std::string& value);
    
    // 约束检查
    bool checkConstraints(const std::string& feature) const;
    void addConstraint(const std::string& constraint);
    
    // 自动生成类名/ID
    std::string generateAutoClassName(const std::string& base = "auto");
    std::string generateAutoId(const std::string& base = "auto");
    
    // 文件和位置信息
    void setCurrentFile(const std::string& file) { currentFile = file; }
    void setCurrentLine(int line) { currentLine = line; }
    std::string getCurrentFile() const { return currentFile; }
    int getCurrentLine() const { return currentLine; }
    
    // 错误报告
    void reportError(const std::string& message);
    void reportWarning(const std::string& message);
    
    // 验证
    bool validate() const;
    
    // 重置上下文
    void reset();
};

// 模板定义基类
class TemplateDefinition {
protected:
    std::string name;
    std::string type;  // @Style, @Element, @Var
    std::unordered_map<std::string, std::string> properties;
    std::vector<std::string> inherited;  // 继承的模板
    
public:
    TemplateDefinition(const std::string& n, const std::string& t) : name(n), type(t) {}
    virtual ~TemplateDefinition() = default;
    
    const std::string& getName() const { return name; }
    const std::string& getType() const { return type; }
    
    virtual void addProperty(const std::string& key, const std::string& value);
    virtual std::optional<std::string> getProperty(const std::string& key) const;
    virtual void inherit(const std::string& templateName);
};

// 自定义定义基类
class CustomDefinition : public TemplateDefinition {
protected:
    std::vector<std::string> deletedProperties;
    std::unordered_map<std::string, std::string> specializations;
    
public:
    CustomDefinition(const std::string& n, const std::string& t) : TemplateDefinition(n, t) {}
    
    void deleteProperty(const std::string& prop);
    void addSpecialization(const std::string& key, const std::string& value);
    bool isDeleted(const std::string& prop) const;
};

// 命名空间定义
class NamespaceDefinition {
private:
    std::string name;
    std::vector<std::string> nestedNamespaces;
    std::vector<std::string> constraints;
    std::shared_ptr<Scope> scope;
    
public:
    NamespaceDefinition(const std::string& n) : name(n) {}
    
    void addNestedNamespace(const std::string& ns);
    void addConstraint(const std::string& constraint);
    bool isAllowed(const std::string& feature) const;
    void setScope(std::shared_ptr<Scope> s) { scope = s; }
    std::shared_ptr<Scope> getScope() const { return scope; }
};

} // namespace chtl

#endif // CHTL_CONTEXT_H