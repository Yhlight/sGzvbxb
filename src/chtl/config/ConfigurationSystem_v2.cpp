#include "ConfigurationSystem.h"
#include "../parser/standalone/ConfigParser.h"
#include <fstream>
#include <sstream>
#include <algorithm>

namespace chtl {
namespace config {

// ä½¿ç”¨ç‹¬ç«‹çš„é…ç½®è§£æå™¨ï¼Œä¸ä¾èµ–ANTLR4
bool ConfigurationSystem::loadFromFile(const std::string& filepath) {
    std::ifstream file(filepath);
    if (!file.is_open()) {
        std::cerr << "Error: Cannot open configuration file: " << filepath << std::endl;
        return false;
    }
    
    std::stringstream buffer;
    buffer << file.rdbuf();
    std::string content = buffer.str();
    
    return loadFromString(content);
}

bool ConfigurationSystem::loadFromString(const std::string& content) {
    // ä½¿ç”¨ç‹¬ç«‹çš„é…ç½®è§£æå™¨
    parser::ConfigLexer lexer(content);
    auto tokens = lexer.tokenize();
    auto tokenStream = std::make_shared<parser::TokenStream>(tokens);
    
    parser::ConfigParser parser(tokenStream);
    auto result = parser.parse();
    
    if (!result.success) {
        std::cerr << "Configuration parse error: " << result.error << std::endl;
        return false;
    }
    
    // æ¸…ç©ºç°æœ‰é…ç½®
    configurations_.clear();
    nameGroups_.clear();
    
    // å¤„ç†è§£æç»“æœ
    for (const auto& [groupName, entries] : result.groups) {
        if (groupName == "DEFAULT" || groupName.empty()) {
            // é»˜è®¤ç»„ç›´æ¥å¤„ç†
            for (const auto& [key, value] : entries) {
                configurations_[key] = value;
            }
        } else if (groupName == "Configuration") {
            // é…ç½®ç»„
            for (const auto& [key, value] : entries) {
                configurations_[key] = value;
            }
        } else {
            // åç§°ç»„
            NameGroup group;
            group.name = groupName;
            
            for (const auto& [key, value] : entries) {
                group.options[key] = value;
            }
            
            nameGroups_[groupName] = group;
        }
    }
    
    // åº”ç”¨é»˜è®¤é…ç½®
    applyDefaults();
    
    // éªŒè¯é…ç½®
    if (!validateConfiguration()) {
        return false;
    }
    
    return true;
}

// ä¿å­˜é…ç½®åˆ°æ–‡ä»¶
bool ConfigurationSystem::saveToFile(const std::string& filepath) const {
    std::ofstream file(filepath);
    if (!file.is_open()) {
        std::cerr << "Error: Cannot create configuration file: " << filepath << std::endl;
        return false;
    }
    
    // å†™å…¥å¤´éƒ¨æ³¨é‡Š
    file << "# CHTL Configuration File\n";
    file << "# Generated by CHTL Compiler\n\n";
    
    // å†™å…¥é…ç½®ç»„
    file << "[Configuration]\n";
    for (const auto& [key, value] : configurations_) {
        file << key << " = " << value << "\n";
    }
    file << "\n";
    
    // å†™å…¥åç§°ç»„
    for (const auto& [name, group] : nameGroups_) {
        file << "[" << name << "]\n";
        for (const auto& [key, value] : group.options) {
            file << key << " = " << value << "\n";
        }
        file << "\n";
    }
    
    return true;
}

// è·å–é…ç½®å€¼ï¼ˆå¸¦é»˜è®¤å€¼ï¼‰
std::string ConfigurationSystem::getConfig(const std::string& key, 
                                          const std::string& defaultValue) const {
    auto it = configurations_.find(key);
    if (it != configurations_.end()) {
        return it->second;
    }
    return defaultValue;
}

// è®¾ç½®é…ç½®å€¼
void ConfigurationSystem::setConfig(const std::string& key, const std::string& value) {
    configurations_[key] = value;
}

// è·å–åç§°ç»„
const ConfigurationSystem::NameGroup* ConfigurationSystem::getNameGroup(
    const std::string& name) const {
    auto it = nameGroups_.find(name);
    if (it != nameGroups_.end()) {
        return &it->second;
    }
    return nullptr;
}

// æ·»åŠ åç§°ç»„
void ConfigurationSystem::addNameGroup(const NameGroup& group) {
    nameGroups_[group.name] = group;
}

// è·å–æ‰€æœ‰é…ç½®é”®
std::vector<std::string> ConfigurationSystem::getConfigKeys() const {
    std::vector<std::string> keys;
    for (const auto& [key, _] : configurations_) {
        keys.push_back(key);
    }
    return keys;
}

// è·å–æ‰€æœ‰åç§°ç»„
std::vector<std::string> ConfigurationSystem::getNameGroups() const {
    std::vector<std::string> names;
    for (const auto& [name, _] : nameGroups_) {
        names.push_back(name);
    }
    return names;
}

// åº”ç”¨é»˜è®¤é…ç½®
void ConfigurationSystem::applyDefaults() {
    // å…³é”®å­—æ˜ å°„é»˜è®¤å€¼
    if (configurations_.find("KEYWORD_TEMPLATE") == configurations_.end()) {
        configurations_["KEYWORD_TEMPLATE"] = "[Template]";
    }
    if (configurations_.find("KEYWORD_CUSTOM") == configurations_.end()) {
        configurations_["KEYWORD_CUSTOM"] = "[Custom]";
    }
    if (configurations_.find("KEYWORD_IMPORT") == configurations_.end()) {
        configurations_["KEYWORD_IMPORT"] = "[Import]";
    }
    if (configurations_.find("KEYWORD_NAMESPACE") == configurations_.end()) {
        configurations_["KEYWORD_NAMESPACE"] = "[Namespace]";
    }
    if (configurations_.find("KEYWORD_ORIGIN") == configurations_.end()) {
        configurations_["KEYWORD_ORIGIN"] = "[Origin]";
    }
    
    // @ å…³é”®å­—
    if (configurations_.find("KEYWORD_ELEMENT") == configurations_.end()) {
        configurations_["KEYWORD_ELEMENT"] = "@Element";
    }
    if (configurations_.find("KEYWORD_STYLE") == configurations_.end()) {
        configurations_["KEYWORD_STYLE"] = "@Style";
    }
    if (configurations_.find("KEYWORD_VAR") == configurations_.end()) {
        configurations_["KEYWORD_VAR"] = "@Var";
    }
    
    // å…¶ä»–é…ç½®
    if (configurations_.find("ENABLE_CUSTOM_KEYWORDS") == configurations_.end()) {
        configurations_["ENABLE_CUSTOM_KEYWORDS"] = "true";
    }
    if (configurations_.find("OPTION_COUNT_LIMIT") == configurations_.end()) {
        configurations_["OPTION_COUNT_LIMIT"] = "1000";
    }
}

// éªŒè¯é…ç½®
bool ConfigurationSystem::validateConfiguration() {
    // æ£€æŸ¥é€‰é¡¹æ•°é‡é™åˆ¶
    std::string limitStr = getConfig("OPTION_COUNT_LIMIT", "1000");
    try {
        int limit = std::stoi(limitStr);
        for (const auto& [name, group] : nameGroups_) {
            if (group.options.size() > static_cast<size_t>(limit)) {
                std::cerr << "Error: Name group '" << name 
                         << "' exceeds option limit (" << limit << ")" << std::endl;
                return false;
            }
        }
    } catch (...) {
        std::cerr << "Error: Invalid OPTION_COUNT_LIMIT value" << std::endl;
        return false;
    }
    
    // æ£€æŸ¥å…³é”®å­—å†²çª
    std::unordered_map<std::string, std::string> usedKeywords;
    for (const auto& [key, value] : configurations_) {
        if (key.find("KEYWORD_") == 0) {
            if (usedKeywords.find(value) != usedKeywords.end()) {
                std::cerr << "Error: Keyword conflict - '" << value 
                         << "' used by both " << key << " and " 
                         << usedKeywords[value] << std::endl;
                return false;
            }
            usedKeywords[value] = key;
        }
    }
    
    return true;
}

// åˆ›å»ºç¤ºä¾‹é…ç½®æ–‡ä»¶
void ConfigurationSystem::createExampleConfig(const std::string& filepath) {
    std::ofstream file(filepath);
    if (!file.is_open()) return;
    
    file << R"(# CHTL Configuration Example
# This file demonstrates the configuration system

[Configuration]
# Enable custom keyword definitions
ENABLE_CUSTOM_KEYWORDS = true

# Maximum number of options per name group
OPTION_COUNT_LIMIT = 1000

# Keyword customization - Standard syntax
KEYWORD_TEMPLATE = [Template]
KEYWORD_CUSTOM = [Custom]
KEYWORD_IMPORT = [Import]
KEYWORD_NAMESPACE = [Namespace]
KEYWORD_ORIGIN = [Origin]

# @ keywords
KEYWORD_ELEMENT = @Element
KEYWORD_STYLE = @Style
KEYWORD_VAR = @Var
KEYWORD_MODULE = @Module
KEYWORD_CHTL = @Chtl
KEYWORD_CJMOD = @CJmod

# Alternative syntax examples (commented out)
# KEYWORD_TEMPLATE = Template
# KEYWORD_CUSTOM = <custom>
# KEYWORD_ELEMENT = Element:
# KEYWORD_STYLE = ::Style

# Name Groups - Define your own replacements
[MyKeywords]
BEGIN = {
END = }
DEFINE = :=
USE = ->

[PythonStyle]
Template = class
Element = def
Style = style
Import = import
Namespace = module

[EmojiStyle]
Template = ğŸ“
Custom = âš™ï¸
Element = ğŸ—ï¸
Style = ğŸ¨
Import = ğŸ“¦
Namespace = ğŸŒ
)";
}

} // namespace config
} // namespace chtl