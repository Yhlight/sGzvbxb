#include "ConfigurationSystem.h"
#include "../parser/standalone/ConfigParser.h"
#include <fstream>
#include <sstream>
#include <algorithm>

namespace chtl {
namespace config {

// 使用独立的配置解析器，不依赖ANTLR4
bool ConfigurationSystem::loadFromFile(const std::string& filepath) {
    std::ifstream file(filepath);
    if (!file.is_open()) {
        std::cerr << "Error: Cannot open configuration file: " << filepath << std::endl;
        return false;
    }
    
    std::stringstream buffer;
    buffer << file.rdbuf();
    std::string content = buffer.str();
    
    return loadFromString(content);
}

bool ConfigurationSystem::loadFromString(const std::string& content) {
    // 使用独立的配置解析器
    parser::ConfigLexer lexer(content);
    auto tokens = lexer.tokenize();
    auto tokenStream = std::make_shared<parser::TokenStream>(tokens);
    
    parser::ConfigParser parser(tokenStream);
    auto result = parser.parse();
    
    if (!result.success) {
        std::cerr << "Configuration parse error: " << result.error << std::endl;
        return false;
    }
    
    // 清空现有配置
    configurations_.clear();
    nameGroups_.clear();
    
    // 处理解析结果
    for (const auto& [groupName, entries] : result.groups) {
        if (groupName == "DEFAULT" || groupName.empty()) {
            // 默认组直接处理
            for (const auto& [key, value] : entries) {
                configurations_[key] = value;
            }
        } else if (groupName == "Configuration") {
            // 配置组
            for (const auto& [key, value] : entries) {
                configurations_[key] = value;
            }
        } else {
            // 名称组
            NameGroup group;
            group.name = groupName;
            
            for (const auto& [key, value] : entries) {
                group.options[key] = value;
            }
            
            nameGroups_[groupName] = group;
        }
    }
    
    // 应用默认配置
    applyDefaults();
    
    // 验证配置
    if (!validateConfiguration()) {
        return false;
    }
    
    return true;
}

// 保存配置到文件
bool ConfigurationSystem::saveToFile(const std::string& filepath) const {
    std::ofstream file(filepath);
    if (!file.is_open()) {
        std::cerr << "Error: Cannot create configuration file: " << filepath << std::endl;
        return false;
    }
    
    // 写入头部注释
    file << "# CHTL Configuration File\n";
    file << "# Generated by CHTL Compiler\n\n";
    
    // 写入配置组
    file << "[Configuration]\n";
    for (const auto& [key, value] : configurations_) {
        file << key << " = " << value << "\n";
    }
    file << "\n";
    
    // 写入名称组
    for (const auto& [name, group] : nameGroups_) {
        file << "[" << name << "]\n";
        for (const auto& [key, value] : group.options) {
            file << key << " = " << value << "\n";
        }
        file << "\n";
    }
    
    return true;
}

// 获取配置值（带默认值）
std::string ConfigurationSystem::getConfig(const std::string& key, 
                                          const std::string& defaultValue) const {
    auto it = configurations_.find(key);
    if (it != configurations_.end()) {
        return it->second;
    }
    return defaultValue;
}

// 设置配置值
void ConfigurationSystem::setConfig(const std::string& key, const std::string& value) {
    configurations_[key] = value;
}

// 获取名称组
const ConfigurationSystem::NameGroup* ConfigurationSystem::getNameGroup(
    const std::string& name) const {
    auto it = nameGroups_.find(name);
    if (it != nameGroups_.end()) {
        return &it->second;
    }
    return nullptr;
}

// 添加名称组
void ConfigurationSystem::addNameGroup(const NameGroup& group) {
    nameGroups_[group.name] = group;
}

// 获取所有配置键
std::vector<std::string> ConfigurationSystem::getConfigKeys() const {
    std::vector<std::string> keys;
    for (const auto& [key, _] : configurations_) {
        keys.push_back(key);
    }
    return keys;
}

// 获取所有名称组
std::vector<std::string> ConfigurationSystem::getNameGroups() const {
    std::vector<std::string> names;
    for (const auto& [name, _] : nameGroups_) {
        names.push_back(name);
    }
    return names;
}

// 应用默认配置
void ConfigurationSystem::applyDefaults() {
    // 关键字映射默认值
    if (configurations_.find("KEYWORD_TEMPLATE") == configurations_.end()) {
        configurations_["KEYWORD_TEMPLATE"] = "[Template]";
    }
    if (configurations_.find("KEYWORD_CUSTOM") == configurations_.end()) {
        configurations_["KEYWORD_CUSTOM"] = "[Custom]";
    }
    if (configurations_.find("KEYWORD_IMPORT") == configurations_.end()) {
        configurations_["KEYWORD_IMPORT"] = "[Import]";
    }
    if (configurations_.find("KEYWORD_NAMESPACE") == configurations_.end()) {
        configurations_["KEYWORD_NAMESPACE"] = "[Namespace]";
    }
    if (configurations_.find("KEYWORD_ORIGIN") == configurations_.end()) {
        configurations_["KEYWORD_ORIGIN"] = "[Origin]";
    }
    
    // @ 关键字
    if (configurations_.find("KEYWORD_ELEMENT") == configurations_.end()) {
        configurations_["KEYWORD_ELEMENT"] = "@Element";
    }
    if (configurations_.find("KEYWORD_STYLE") == configurations_.end()) {
        configurations_["KEYWORD_STYLE"] = "@Style";
    }
    if (configurations_.find("KEYWORD_VAR") == configurations_.end()) {
        configurations_["KEYWORD_VAR"] = "@Var";
    }
    
    // 其他配置
    if (configurations_.find("ENABLE_CUSTOM_KEYWORDS") == configurations_.end()) {
        configurations_["ENABLE_CUSTOM_KEYWORDS"] = "true";
    }
    if (configurations_.find("OPTION_COUNT_LIMIT") == configurations_.end()) {
        configurations_["OPTION_COUNT_LIMIT"] = "1000";
    }
}

// 验证配置
bool ConfigurationSystem::validateConfiguration() {
    // 检查选项数量限制
    std::string limitStr = getConfig("OPTION_COUNT_LIMIT", "1000");
    try {
        int limit = std::stoi(limitStr);
        for (const auto& [name, group] : nameGroups_) {
            if (group.options.size() > static_cast<size_t>(limit)) {
                std::cerr << "Error: Name group '" << name 
                         << "' exceeds option limit (" << limit << ")" << std::endl;
                return false;
            }
        }
    } catch (...) {
        std::cerr << "Error: Invalid OPTION_COUNT_LIMIT value" << std::endl;
        return false;
    }
    
    // 检查关键字冲突
    std::unordered_map<std::string, std::string> usedKeywords;
    for (const auto& [key, value] : configurations_) {
        if (key.find("KEYWORD_") == 0) {
            if (usedKeywords.find(value) != usedKeywords.end()) {
                std::cerr << "Error: Keyword conflict - '" << value 
                         << "' used by both " << key << " and " 
                         << usedKeywords[value] << std::endl;
                return false;
            }
            usedKeywords[value] = key;
        }
    }
    
    return true;
}

// 创建示例配置文件
void ConfigurationSystem::createExampleConfig(const std::string& filepath) {
    std::ofstream file(filepath);
    if (!file.is_open()) return;
    
    file << R"(# CHTL Configuration Example
# This file demonstrates the configuration system

[Configuration]
# Enable custom keyword definitions
ENABLE_CUSTOM_KEYWORDS = true

# Maximum number of options per name group
OPTION_COUNT_LIMIT = 1000

# Keyword customization - Standard syntax
KEYWORD_TEMPLATE = [Template]
KEYWORD_CUSTOM = [Custom]
KEYWORD_IMPORT = [Import]
KEYWORD_NAMESPACE = [Namespace]
KEYWORD_ORIGIN = [Origin]

# @ keywords
KEYWORD_ELEMENT = @Element
KEYWORD_STYLE = @Style
KEYWORD_VAR = @Var
KEYWORD_MODULE = @Module
KEYWORD_CHTL = @Chtl
KEYWORD_CJMOD = @CJmod

# Alternative syntax examples (commented out)
# KEYWORD_TEMPLATE = Template
# KEYWORD_CUSTOM = <custom>
# KEYWORD_ELEMENT = Element:
# KEYWORD_STYLE = ::Style

# Name Groups - Define your own replacements
[MyKeywords]
BEGIN = {
END = }
DEFINE = :=
USE = ->

[PythonStyle]
Template = class
Element = def
Style = style
Import = import
Namespace = module

[EmojiStyle]
Template = 📝
Custom = ⚙️
Element = 🏗️
Style = 🎨
Import = 📦
Namespace = 🌐
)";
}

} // namespace config
} // namespace chtl