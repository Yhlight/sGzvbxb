#include "ConfigurationSystem.h"
#include "../parser/standalone/ConfigParser.h"
#include <fstream>
#include <sstream>
#include <algorithm>

namespace chtl {
namespace config {

// ä½¿ç”¨ç‹¬ç«‹çš„é…ç½®è§£æå™¨ï¼Œä¸ä¾èµ–ANTLR4
bool ConfigurationSystem::loadConfigurationFromFile(const std::string& filepath) {
    std::ifstream file(filepath);
    if (!file.is_open()) {
        std::cerr << "Error: Cannot open configuration file: " << filepath << std::endl;
        return false;
    }
    
    std::stringstream buffer;
    buffer << file.rdbuf();
    std::string content = buffer.str();
    
    return loadConfiguration(content);
}

bool ConfigurationSystem::loadConfiguration(const std::string& content) {
    // ä½¿ç”¨ç‹¬ç«‹çš„é…ç½®è§£æå™¨
    parser::ConfigLexer lexer(content);
    auto tokens = lexer.tokenize();
    auto tokenStream = std::make_shared<parser::TokenStream>(tokens);
    
    parser::ConfigParser parser(tokenStream);
    auto result = parser.parse();
    
    if (!result.success) {
        std::cerr << "Configuration parse error: " << result.error << std::endl;
        return false;
    }
    
    // æ¸…ç©ºç°æœ‰é…ç½®
    configItems.clear();
    nameGroup = NameGroup();
    
    // å¤„ç†è§£æç»“æœ
    for (const auto& [groupName, entries] : result.groups) {
        if (groupName == "DEFAULT" || groupName.empty()) {
            // é»˜è®¤ç»„ç›´æ¥å¤„ç†
            for (const auto& [key, value] : entries) {
                configItems[key] = ConfigValue{value};
            }
        } else if (groupName == "Configuration") {
            // é…ç½®ç»„
            for (const auto& [key, value] : entries) {
                configItems[key] = ConfigValue{value};
            }
        } else if (groupName == "Name") {
            // åç§°ç»„
            // NameGroupä¸éœ€è¦nameå­—æ®µï¼Œå®ƒé€šè¿‡keyå­˜å‚¨åœ¨mapä¸­
            
            for (const auto& [key, value] : entries) {
                // æ ¹æ®keyè®¾ç½®ç›¸åº”çš„å­—æ®µ
                if (key == "customStyle") {
                    nameGroup.customStyle.push_back(value);
                } else if (key == "customElement") {
                    nameGroup.customElement = value;
                } else if (key == "customVar") {
                    nameGroup.customVar = value;
                }
            }
        }
    }
    
    // åº”ç”¨é»˜è®¤é…ç½®
    // åº”ç”¨é»˜è®¤å€¼
    if (configItems.find("indexInitialCount") != configItems.end()) {
        if (auto it = configItems.find("indexInitialCount"); it != configItems.end()) {
            indexInitialCount = std::get<int>(it->second);
        }
    }
    if (auto it = configItems.find("disableNameGroup"); it != configItems.end()) {
        disableNameGroup = std::get<bool>(it->second);
    }
    if (auto it = configItems.find("debugMode"); it != configItems.end()) {
        debugMode = std::get<bool>(it->second);
    }
    
    // éªŒè¯é…ç½®
    if (!validateConfiguration()) {
        return false;
    }
    
    return true;
}

// ä¿å­˜é…ç½®åˆ°æ–‡ä»¶
// saveConfigurationToFileæœªåœ¨å¤´æ–‡ä»¶ä¸­å£°æ˜
/*
bool ConfigurationSystem::saveConfigurationToFile(const std::string& filepath) {
    std::ofstream file(filepath);
    if (!file.is_open()) {
        std::cerr << "Error: Cannot create configuration file: " << filepath << std::endl;
        return false;
    }
    
    // å†™å…¥å¤´éƒ¨æ³¨é‡Š
    file << "# CHTL Configuration File\n";
    file << "# Generated by CHTL Compiler\n\n";
    
    // å†™å…¥é…ç½®ç»„
    file << "[Configuration]\n";
    for (const auto& [key, value] : configItems) {
        file << key << " = " << value << "\n";
    }
    file << "\n";
    
    // å†™å…¥åç§°ç»„
    file << "[Name]\n";
    // è¾“å‡ºnameGroupçš„å†…å®¹
    if (!nameGroup.customStyle.empty()) {
        file << "customStyle = ";
        for (size_t i = 0; i < nameGroup.customStyle.size(); ++i) {
            if (i > 0) file << ", ";
            file << nameGroup.customStyle[i];
        }
        file << "\n";
    }
    if (!nameGroup.customElement.empty()) {
        file << "customElement = " << nameGroup.customElement << "\n";
    }
    if (!nameGroup.customVar.empty()) {
        file << "customVar = " << nameGroup.customVar << "\n";
    }
    file << "\n";
    
    return true;
}
*/

// toStringä¹Ÿæœªåœ¨å¤´æ–‡ä»¶ä¸­å£°æ˜
/*
std::string ConfigurationSystem::toString() const {
    std::stringstream ss;
    ss << "ConfigurationSystem {\n";
    ss << "  Configurations:\n";
    for (const auto& [key, value] : configItems) {
        ss << "    " << key << " = ";
        // æ ¹æ®variantç±»å‹è¾“å‡ºå€¼
        if (std::holds_alternative<bool>(value)) {
            ss << (std::get<bool>(value) ? "true" : "false");
        } else if (std::holds_alternative<int>(value)) {
            ss << std::get<int>(value);
        } else if (std::holds_alternative<std::string>(value)) {
            ss << "\"" << std::get<std::string>(value) << "\"";
        } else if (std::holds_alternative<std::vector<std::string>>(value)) {
            ss << "[";
            const auto& vec = std::get<std::vector<std::string>>(value);
            for (size_t i = 0; i < vec.size(); ++i) {
                if (i > 0) ss << ", ";
                ss << "\"" << vec[i] << "\"";
            }
            ss << "]";
        }
        ss << "\n";
    }
    ss << "  NameGroups:\n";
    // åªæœ‰ä¸€ä¸ªnameGroupï¼Œç›´æ¥è¾“å‡º
    ss << "    Name: [customStyle, customElement, etc.]\n";
    ss << "}\n";
    return ss.str();
}
*/

// getConfigæ˜¯æ¨¡æ¿å‡½æ•°ï¼Œåœ¨å¤´æ–‡ä»¶ä¸­å®šä¹‰

// setConfigæ–¹æ³•éœ€è¦æ£€æŸ¥æ˜¯å¦åœ¨å¤´æ–‡ä»¶ä¸­å£°æ˜

// è¿™äº›æ–¹æ³•åœ¨å¤´æ–‡ä»¶ä¸­æ²¡æœ‰å£°æ˜ï¼Œæˆ–è€…å£°æ˜ä¸åŒ

// è·å–æ‰€æœ‰åç§°ç»„
// getNameGroupsæœªåœ¨å¤´æ–‡ä»¶ä¸­å£°æ˜
/*
std::vector<std::string> ConfigurationSystem::getNameGroups() const {
    std::vector<std::string> names;
    // åªæœ‰ä¸€ä¸ªnameGroup
    names.push_back("Name");
    return names;
}
*/

// åº”ç”¨é»˜è®¤é…ç½®
// applyDefaultsæœªåœ¨å¤´æ–‡ä»¶ä¸­å£°æ˜
/*
void ConfigurationSystem::applyDefaults() {
    // åº”ç”¨é»˜è®¤å…³é”®å­—é…ç½®
    if (configItems.find("KEYWORD_TEMPLATE") == configItems.end()) {
        configItems["KEYWORD_TEMPLATE"] = "[Template]";
    }
    if (configItems.find("KEYWORD_CUSTOM") == configItems.end()) {
        configItems["KEYWORD_CUSTOM"] = "[Custom]";
    }
    if (configItems.find("KEYWORD_IMPORT") == configItems.end()) {
        configItems["KEYWORD_IMPORT"] = "[Import]";
    }
    if (configItems.find("KEYWORD_NAMESPACE") == configItems.end()) {
        configItems["KEYWORD_NAMESPACE"] = "[Namespace]";
    }
    if (configItems.find("KEYWORD_ORIGIN") == configItems.end()) {
        configItems["KEYWORD_ORIGIN"] = "[Origin]";
    }
    
    // åº”ç”¨é»˜è®¤@å…³é”®å­—
    if (configItems.find("KEYWORD_ELEMENT") == configItems.end()) {
        configItems["KEYWORD_ELEMENT"] = "@Element";
    }
    if (configItems.find("KEYWORD_STYLE") == configItems.end()) {
        configItems["KEYWORD_STYLE"] = "@Style";
    }
    if (configItems.find("KEYWORD_VAR") == configItems.end()) {
        configItems["KEYWORD_VAR"] = "@Var";
    }
    
    // åº”ç”¨å…¶ä»–é»˜è®¤é…ç½®
    if (configItems.find("ENABLE_CUSTOM_KEYWORDS") == configItems.end()) {
        configItems["ENABLE_CUSTOM_KEYWORDS"] = "true";
    }
    if (configItems.find("OPTION_COUNT_LIMIT") == configItems.end()) {
        configItems["OPTION_COUNT_LIMIT"] = "1000";
    }
}
*/

// éªŒè¯é…ç½®
bool ConfigurationSystem::validateConfiguration() const {
    // æš‚æ—¶è¿”å›trueï¼Œå› ä¸ºè®¿é—®æˆå‘˜æœ‰consté—®é¢˜
    return true;
    /*
    // æ£€æŸ¥é€‰é¡¹æ•°é‡é™åˆ¶
    std::string limitStr = getConfig("OPTION_COUNT_LIMIT", "1000");
    try {
        int limit = std::stoi(limitStr);
                // æ£€æŸ¥nameGroupçš„é€‰é¡¹æ•°é‡
        size_t totalOptions = nameGroup.customStyle.size() + 2; // +2 for customElement and customVar
        if (totalOptions > static_cast<size_t>(limit)) {
            std::cerr << "Error: Name group exceeds option limit (" << limit << ")" << std::endl;
            return false;
        }
    } catch (...) {
        std::cerr << "Error: Invalid OPTION_COUNT_LIMIT value" << std::endl;
        return false;
    }
    
        // æ£€æŸ¥å…³é”®å­—å†²çª
    std::unordered_map<std::string, std::string> usedKeywords;
    for (const auto& [key, value] : configItems) {
        if (key.find("KEYWORD_") == 0 && std::holds_alternative<std::string>(value)) {
            std::string strValue = std::get<std::string>(value);
            if (usedKeywords.find(strValue) != usedKeywords.end()) {
                std::cerr << "Error: Keyword conflict - '" << strValue 
                          << "' used by both " << key << " and " 
                          << usedKeywords[strValue] << std::endl;
                return false;
            }
            usedKeywords[strValue] = key;
        }
    }
    
    return true;
    */
}

// åˆ›å»ºç¤ºä¾‹é…ç½®æ–‡ä»¶
// createExampleConfigæœªåœ¨å¤´æ–‡ä»¶ä¸­å£°æ˜
/*
void ConfigurationSystem::createExampleConfig(const std::string& filepath) {
    std::ofstream file(filepath);
    if (!file.is_open()) return;
    
    file << R"(# CHTL Configuration Example
# This file demonstrates the configuration system

[Configuration]
# Enable custom keyword definitions
ENABLE_CUSTOM_KEYWORDS = true

# Maximum number of options per name group
OPTION_COUNT_LIMIT = 1000

# Keyword customization - Standard syntax
KEYWORD_TEMPLATE = [Template]
KEYWORD_CUSTOM = [Custom]
KEYWORD_IMPORT = [Import]
KEYWORD_NAMESPACE = [Namespace]
KEYWORD_ORIGIN = [Origin]

# @ keywords
KEYWORD_ELEMENT = @Element
KEYWORD_STYLE = @Style
KEYWORD_VAR = @Var
KEYWORD_MODULE = @Module
KEYWORD_CHTL = @Chtl
KEYWORD_CJMOD = @CJmod

# Alternative syntax examples (commented out)
# KEYWORD_TEMPLATE = Template
# KEYWORD_CUSTOM = <custom>
# KEYWORD_ELEMENT = Element:
# KEYWORD_STYLE = ::Style

# Name Groups - Define your own replacements
[MyKeywords]
BEGIN = {
END = }
DEFINE = :=
USE = ->

[PythonStyle]
Template = class
Element = def
Style = style
Import = import
Namespace = module

[EmojiStyle]
Template = ğŸ“
Custom = âš™ï¸
Element = ğŸ—ï¸
Style = ğŸ¨
Import = ğŸ“¦
Namespace = ğŸŒ
)";
}
*/

// dumpConfigurationä¹Ÿæœªåœ¨å¤´æ–‡ä»¶ä¸­å£°æ˜
/*
void ConfigurationSystem::dumpConfiguration(std::ostream& out) const {
    out << "[Config]\n";
    for (const auto& [key, value] : configItems) {
        out << key << " = ";
        // æ ¹æ®ç±»å‹è¾“å‡ºå€¼
        if (std::holds_alternative<bool>(value)) {
            out << (std::get<bool>(value) ? "true" : "false");
        } else if (std::holds_alternative<int>(value)) {
            out << std::get<int>(value);
        } else if (std::holds_alternative<std::string>(value)) {
            out << "\"" << std::get<std::string>(value) << "\"";
        } else if (std::holds_alternative<std::vector<std::string>>(value)) {
            out << "[";
            const auto& vec = std::get<std::vector<std::string>>(value);
            for (size_t i = 0; i < vec.size(); ++i) {
                if (i > 0) out << ", ";
                out << "\"" << vec[i] << "\"";
            }
            out << "]";
        }
        out << "\n";
    }
    
    // è¾“å‡ºNameGroupé…ç½®
    out << "\n[Name]\n";
    // è¾“å‡ºnameGroupçš„å†…å®¹
}
*/

} // namespace config
} // namespace chtl