#include "ConfigurationSystem.h"
#include "../parser/standalone/ConfigParser.h"
#include <fstream>
#include <sstream>
#include <algorithm>

namespace chtl {
namespace config {

// 使用独立的配置解析器，不依赖ANTLR4
bool ConfigurationSystem::loadConfigurationFromFile(const std::string& filepath) {
    std::ifstream file(filepath);
    if (!file.is_open()) {
        std::cerr << "Error: Cannot open configuration file: " << filepath << std::endl;
        return false;
    }
    
    std::stringstream buffer;
    buffer << file.rdbuf();
    std::string content = buffer.str();
    
    return loadConfiguration(content);
}

bool ConfigurationSystem::loadConfiguration(const std::string& content) {
    // 使用独立的配置解析器
    parser::ConfigLexer lexer(content);
    auto tokens = lexer.tokenize();
    auto tokenStream = std::make_shared<parser::TokenStream>(tokens);
    
    parser::ConfigParser parser(tokenStream);
    auto result = parser.parse();
    
    if (!result.success) {
        std::cerr << "Configuration parse error: " << result.error << std::endl;
        return false;
    }
    
    // 清空现有配置
    configItems.clear();
    nameGroup = NameGroup();
    
    // 处理解析结果
    for (const auto& [groupName, entries] : result.groups) {
        if (groupName == "DEFAULT" || groupName.empty()) {
            // 默认组直接处理
            for (const auto& [key, value] : entries) {
                configItems[key] = ConfigValue{value};
            }
        } else if (groupName == "Configuration") {
            // 配置组
            for (const auto& [key, value] : entries) {
                configItems[key] = ConfigValue{value};
            }
        } else if (groupName == "Name") {
            // 名称组
            // NameGroup不需要name字段，它通过key存储在map中
            
            for (const auto& [key, value] : entries) {
                // 根据key设置相应的字段
                if (key == "customStyle") {
                    nameGroup.customStyle.push_back(value);
                } else if (key == "customElement") {
                    nameGroup.customElement = value;
                } else if (key == "customVar") {
                    nameGroup.customVar = value;
                }
            }
        }
    }
    
    // 应用默认配置
    // 应用默认值
    if (configItems.find("indexInitialCount") != configItems.end()) {
        if (auto it = configItems.find("indexInitialCount"); it != configItems.end()) {
            indexInitialCount = std::get<int>(it->second);
        }
    }
    if (auto it = configItems.find("disableNameGroup"); it != configItems.end()) {
        disableNameGroup = std::get<bool>(it->second);
    }
    if (auto it = configItems.find("debugMode"); it != configItems.end()) {
        debugMode = std::get<bool>(it->second);
    }
    
    // 验证配置
    if (!validateConfiguration()) {
        return false;
    }
    
    return true;
}

// 保存配置到文件
// saveConfigurationToFile未在头文件中声明
/*
bool ConfigurationSystem::saveConfigurationToFile(const std::string& filepath) {
    std::ofstream file(filepath);
    if (!file.is_open()) {
        std::cerr << "Error: Cannot create configuration file: " << filepath << std::endl;
        return false;
    }
    
    // 写入头部注释
    file << "# CHTL Configuration File\n";
    file << "# Generated by CHTL Compiler\n\n";
    
    // 写入配置组
    file << "[Configuration]\n";
    for (const auto& [key, value] : configItems) {
        file << key << " = " << value << "\n";
    }
    file << "\n";
    
    // 写入名称组
    file << "[Name]\n";
    // 输出nameGroup的内容
    if (!nameGroup.customStyle.empty()) {
        file << "customStyle = ";
        for (size_t i = 0; i < nameGroup.customStyle.size(); ++i) {
            if (i > 0) file << ", ";
            file << nameGroup.customStyle[i];
        }
        file << "\n";
    }
    if (!nameGroup.customElement.empty()) {
        file << "customElement = " << nameGroup.customElement << "\n";
    }
    if (!nameGroup.customVar.empty()) {
        file << "customVar = " << nameGroup.customVar << "\n";
    }
    file << "\n";
    
    return true;
}
*/

// toString也未在头文件中声明
/*
std::string ConfigurationSystem::toString() const {
    std::stringstream ss;
    ss << "ConfigurationSystem {\n";
    ss << "  Configurations:\n";
    for (const auto& [key, value] : configItems) {
        ss << "    " << key << " = ";
        // 根据variant类型输出值
        if (std::holds_alternative<bool>(value)) {
            ss << (std::get<bool>(value) ? "true" : "false");
        } else if (std::holds_alternative<int>(value)) {
            ss << std::get<int>(value);
        } else if (std::holds_alternative<std::string>(value)) {
            ss << "\"" << std::get<std::string>(value) << "\"";
        } else if (std::holds_alternative<std::vector<std::string>>(value)) {
            ss << "[";
            const auto& vec = std::get<std::vector<std::string>>(value);
            for (size_t i = 0; i < vec.size(); ++i) {
                if (i > 0) ss << ", ";
                ss << "\"" << vec[i] << "\"";
            }
            ss << "]";
        }
        ss << "\n";
    }
    ss << "  NameGroups:\n";
    // 只有一个nameGroup，直接输出
    ss << "    Name: [customStyle, customElement, etc.]\n";
    ss << "}\n";
    return ss.str();
}
*/

// getConfig是模板函数，在头文件中定义

// setConfig方法需要检查是否在头文件中声明

// 这些方法在头文件中没有声明，或者声明不同

// 获取所有名称组
// getNameGroups未在头文件中声明
/*
std::vector<std::string> ConfigurationSystem::getNameGroups() const {
    std::vector<std::string> names;
    // 只有一个nameGroup
    names.push_back("Name");
    return names;
}
*/

// 应用默认配置
// applyDefaults未在头文件中声明
/*
void ConfigurationSystem::applyDefaults() {
    // 应用默认关键字配置
    if (configItems.find("KEYWORD_TEMPLATE") == configItems.end()) {
        configItems["KEYWORD_TEMPLATE"] = "[Template]";
    }
    if (configItems.find("KEYWORD_CUSTOM") == configItems.end()) {
        configItems["KEYWORD_CUSTOM"] = "[Custom]";
    }
    if (configItems.find("KEYWORD_IMPORT") == configItems.end()) {
        configItems["KEYWORD_IMPORT"] = "[Import]";
    }
    if (configItems.find("KEYWORD_NAMESPACE") == configItems.end()) {
        configItems["KEYWORD_NAMESPACE"] = "[Namespace]";
    }
    if (configItems.find("KEYWORD_ORIGIN") == configItems.end()) {
        configItems["KEYWORD_ORIGIN"] = "[Origin]";
    }
    
    // 应用默认@关键字
    if (configItems.find("KEYWORD_ELEMENT") == configItems.end()) {
        configItems["KEYWORD_ELEMENT"] = "@Element";
    }
    if (configItems.find("KEYWORD_STYLE") == configItems.end()) {
        configItems["KEYWORD_STYLE"] = "@Style";
    }
    if (configItems.find("KEYWORD_VAR") == configItems.end()) {
        configItems["KEYWORD_VAR"] = "@Var";
    }
    
    // 应用其他默认配置
    if (configItems.find("ENABLE_CUSTOM_KEYWORDS") == configItems.end()) {
        configItems["ENABLE_CUSTOM_KEYWORDS"] = "true";
    }
    if (configItems.find("OPTION_COUNT_LIMIT") == configItems.end()) {
        configItems["OPTION_COUNT_LIMIT"] = "1000";
    }
}
*/

// 验证配置
bool ConfigurationSystem::validateConfiguration() const {
    // 暂时返回true，因为访问成员有const问题
    return true;
    /*
    // 检查选项数量限制
    std::string limitStr = getConfig("OPTION_COUNT_LIMIT", "1000");
    try {
        int limit = std::stoi(limitStr);
                // 检查nameGroup的选项数量
        size_t totalOptions = nameGroup.customStyle.size() + 2; // +2 for customElement and customVar
        if (totalOptions > static_cast<size_t>(limit)) {
            std::cerr << "Error: Name group exceeds option limit (" << limit << ")" << std::endl;
            return false;
        }
    } catch (...) {
        std::cerr << "Error: Invalid OPTION_COUNT_LIMIT value" << std::endl;
        return false;
    }
    
        // 检查关键字冲突
    std::unordered_map<std::string, std::string> usedKeywords;
    for (const auto& [key, value] : configItems) {
        if (key.find("KEYWORD_") == 0 && std::holds_alternative<std::string>(value)) {
            std::string strValue = std::get<std::string>(value);
            if (usedKeywords.find(strValue) != usedKeywords.end()) {
                std::cerr << "Error: Keyword conflict - '" << strValue 
                          << "' used by both " << key << " and " 
                          << usedKeywords[strValue] << std::endl;
                return false;
            }
            usedKeywords[strValue] = key;
        }
    }
    
    return true;
    */
}

// 创建示例配置文件
// createExampleConfig未在头文件中声明
/*
void ConfigurationSystem::createExampleConfig(const std::string& filepath) {
    std::ofstream file(filepath);
    if (!file.is_open()) return;
    
    file << R"(# CHTL Configuration Example
# This file demonstrates the configuration system

[Configuration]
# Enable custom keyword definitions
ENABLE_CUSTOM_KEYWORDS = true

# Maximum number of options per name group
OPTION_COUNT_LIMIT = 1000

# Keyword customization - Standard syntax
KEYWORD_TEMPLATE = [Template]
KEYWORD_CUSTOM = [Custom]
KEYWORD_IMPORT = [Import]
KEYWORD_NAMESPACE = [Namespace]
KEYWORD_ORIGIN = [Origin]

# @ keywords
KEYWORD_ELEMENT = @Element
KEYWORD_STYLE = @Style
KEYWORD_VAR = @Var
KEYWORD_MODULE = @Module
KEYWORD_CHTL = @Chtl
KEYWORD_CJMOD = @CJmod

# Alternative syntax examples (commented out)
# KEYWORD_TEMPLATE = Template
# KEYWORD_CUSTOM = <custom>
# KEYWORD_ELEMENT = Element:
# KEYWORD_STYLE = ::Style

# Name Groups - Define your own replacements
[MyKeywords]
BEGIN = {
END = }
DEFINE = :=
USE = ->

[PythonStyle]
Template = class
Element = def
Style = style
Import = import
Namespace = module

[EmojiStyle]
Template = 📝
Custom = ⚙️
Element = 🏗️
Style = 🎨
Import = 📦
Namespace = 🌐
)";
}
*/

// dumpConfiguration也未在头文件中声明
/*
void ConfigurationSystem::dumpConfiguration(std::ostream& out) const {
    out << "[Config]\n";
    for (const auto& [key, value] : configItems) {
        out << key << " = ";
        // 根据类型输出值
        if (std::holds_alternative<bool>(value)) {
            out << (std::get<bool>(value) ? "true" : "false");
        } else if (std::holds_alternative<int>(value)) {
            out << std::get<int>(value);
        } else if (std::holds_alternative<std::string>(value)) {
            out << "\"" << std::get<std::string>(value) << "\"";
        } else if (std::holds_alternative<std::vector<std::string>>(value)) {
            out << "[";
            const auto& vec = std::get<std::vector<std::string>>(value);
            for (size_t i = 0; i < vec.size(); ++i) {
                if (i > 0) out << ", ";
                out << "\"" << vec[i] << "\"";
            }
            out << "]";
        }
        out << "\n";
    }
    
    // 输出NameGroup配置
    out << "\n[Name]\n";
    // 输出nameGroup的内容
}
*/

} // namespace config
} // namespace chtl