#ifndef CHTL_GENERATOR_H
#define CHTL_GENERATOR_H

#include <string>
#include <vector>
#include <memory>
#include <sstream>
#include <unordered_map>
#include <unordered_set>
#include "CHTLContext.h"
#include "CHTLTemplate.h"  // 添加模板头文件
#include "CHTLCustom.h"    // 添加自定义头文件
#include "CHTLOrigin.h"    // 添加原始嵌入头文件
#include "CHTLImport.h"    // 添加导入头文件
#include "CHTLNamespace.h" // 添加命名空间头文件
#include "CHTLConstraint.h" // 添加约束头文件
#include "CHTLScript.h"    // 添加脚本头文件
#include "CHTLCMOD.h"      // 添加CMOD头文件
#include "CHTLCSSCompiler.h"
#include "CHTLJSCompiler.h"

namespace chtl {

// 元素上下文信息
struct ElementContext {
    std::string name;
    std::string id;
    std::vector<std::string> classes;
    std::map<std::string, std::string> attributes;
    bool hasInlineStyle = false;
};

// 生成选项
struct GeneratorOptions {
    bool preserveGeneratorComments = true;  // 是否保留--注释
    bool generateSourceMap = false;         // 是否生成源码映射
    bool minifyOutput = false;              // 是否压缩输出
    bool autoGenerateIds = true;            // 是否自动生成ID
    bool extractStyleToGlobal = true;      // 是否提取样式到全局
    std::string indentString = "  ";        // 缩进字符串
};

// 样式规则
struct StyleRule {
    std::string selector;
    std::vector<std::pair<std::string, std::string>> properties;
    bool isInline = false;
    std::string sourceElement;  // 来源元素，用于追踪
};

// 生成器类
class CHTLGenerator {
private:
    std::shared_ptr<CHTLContext> context;
    GeneratorOptions options;
    
    // 模板管理器
    std::shared_ptr<TemplateManager> templateManager;
    
    // 自定义管理器
    std::shared_ptr<CustomManager> customManager;
    
    // 原始嵌入管理器
    std::shared_ptr<OriginManager> originManager;
    
    // 导入管理器
    std::shared_ptr<ImportManager> importManager;
    
    // 命名空间管理器
    std::shared_ptr<NamespaceManager> namespaceManager;
    
    // 约束管理器
    std::shared_ptr<ConstraintManager> constraintManager;
    
    // 脚本管理器
    std::shared_ptr<ScriptManager> scriptManager;
    
    // CMOD管理器
    std::shared_ptr<CMODManager> cmodManager;
    
    // CSS处理器
    std::shared_ptr<CHTLCSSProcessor> cssProcessor;
    
    // JavaScript处理器
    std::shared_ptr<CHTLJSProcessor> jsProcessor;
    
    // 输出流
    std::stringstream htmlOutput;
    std::stringstream cssOutput;
    std::stringstream jsOutput;
    
    // 状态跟踪
    int indentLevel;
    std::vector<std::string> elementStack;
    ElementContext currentElement;
    
    // 内联样式累积器
    std::vector<std::pair<std::string, std::string>> pendingInlineStyles;
    bool isAccumulatingInlineStyles = false;
    bool inHeadElement = false;  // 跟踪是否在head元素中
    
    // 样式管理
    std::vector<StyleRule> globalStyles;
    std::unordered_map<std::string, std::string> autoGeneratedClasses;  // 元素 -> 生成的类名
    std::unordered_map<std::string, std::string> autoGeneratedIds;      // 元素 -> 生成的ID
    int autoClassCounter;
    int autoIdCounter;
    
    // 当前脚本内容
    std::string currentScriptContent;
    
    // 注释缓存
    std::vector<std::string> pendingGeneratorComments;
    
    // 辅助方法
    std::string indent() const;
    std::string escapeAttribute(const std::string& attr) const;
    void increaseIndent() { indentLevel++; }
    void decreaseIndent() { if (indentLevel > 0) indentLevel--; }
    
    // 样式处理
    std::string generateAutoClassName(const std::string& hint = "");
    std::string generateAutoId(const std::string& hint = "");
    void extractStyleToGlobal(const StyleRule& rule);
    std::string resolveAmpersand(const std::string& selector, const std::string& context);
    
    // 字面量处理
    std::string processLiteral(const std::string& value, bool inTextBlock = false);
    bool isUnquotedLiteral(const std::string& value) const;
    std::string removeQuotes(const std::string& value) const;
    
public:
    CHTLGenerator(std::shared_ptr<CHTLContext> ctx, const GeneratorOptions& opts = GeneratorOptions());
    ~CHTLGenerator() = default;
    
    // 模板支持
    void setTemplateManager(std::shared_ptr<TemplateManager> mgr) { templateManager = mgr; }
    std::shared_ptr<TemplateManager> getTemplateManager() const { return templateManager; }
    
    // 自定义支持
    void setCustomManager(std::shared_ptr<CustomManager> mgr) { customManager = mgr; }
    std::shared_ptr<CustomManager> getCustomManager() const { return customManager; }
    
    // 原始嵌入支持
    void setOriginManager(std::shared_ptr<OriginManager> mgr) { originManager = mgr; }
    std::shared_ptr<OriginManager> getOriginManager() const { return originManager; }
    
    // 导入支持
    void setImportManager(std::shared_ptr<ImportManager> mgr) { importManager = mgr; }
    std::shared_ptr<ImportManager> getImportManager() const { return importManager; }
    
    // 命名空间支持
    void setNamespaceManager(std::shared_ptr<NamespaceManager> mgr) { namespaceManager = mgr; }
    std::shared_ptr<NamespaceManager> getNamespaceManager() const { return namespaceManager; }
    
    // 约束支持
    void setConstraintManager(std::shared_ptr<ConstraintManager> mgr) { constraintManager = mgr; }
    std::shared_ptr<ConstraintManager> getConstraintManager() const { return constraintManager; }
    
    // 脚本支持
    void setScriptManager(std::shared_ptr<ScriptManager> mgr) { scriptManager = mgr; }
    std::shared_ptr<ScriptManager> getScriptManager() const { return scriptManager; }
    
    // CMOD支持
    void setCMODManager(std::shared_ptr<CMODManager> mgr) { cmodManager = mgr; }
    std::shared_ptr<CMODManager> getCMODManager() const { return cmodManager; }
    
    // CSS处理器
    void setCSSProcessor(std::shared_ptr<CHTLCSSProcessor> processor) { cssProcessor = processor; }
    std::shared_ptr<CHTLCSSProcessor> getCSSProcessor() const { return cssProcessor; }
    
    // JavaScript处理器
    void setJSProcessor(std::shared_ptr<CHTLJSProcessor> processor) { jsProcessor = processor; }
    std::shared_ptr<CHTLJSProcessor> getJSProcessor() const { return jsProcessor; }
    
    // 模板定义
    void beginTemplateDefinition(const std::string& type, const std::string& name);
    void endTemplateDefinition();
    
    // 自定义定义
    void beginCustomDefinition(const std::string& type, const std::string& name);
    void endCustomDefinition();
    
    // 模板使用
    void useTemplate(const std::string& statement);
    std::string processVariableReference(const std::string& reference);
    
    // 自定义使用
    void useCustom(const std::string& statement, 
                  const std::unordered_map<std::string, std::string>& providedValues = {});
    void useCustomWithSpecialization(const std::string& statement,
                                   const std::vector<SpecializationOperation>& specializations);
    
    // 模板继承
    void addTemplateInheritance(const std::string& inheritStatement);
    
    // 特例化支持
    void addSpecialization(const SpecializationOperation& op);
    void addDeleteOperation(const std::string& deleteStatement);
    void addInsertOperation(const std::string& insertStatement);
    
    // 主要生成方法
    void generateElement(const std::string& name, const std::unordered_map<std::string, std::string>& attributes);
    void closeElement();
    
    // 文本节点
    void generateTextNode(const std::string& content);
    void beginTextBlock();
    void endTextBlock();
    
    // 属性生成
    void generateAttribute(const std::string& name, const std::string& value);
    std::string formatAttributeValue(const std::string& value);
    
    // 样式生成
    void beginStyleBlock();
    void endStyleBlock();
    void generateInlineStyle(const std::string& property, const std::string& value);
    void generateStyleRule(const std::string& selector, const std::vector<std::pair<std::string, std::string>>& properties);
    void generateClassRule(const std::string& className, const std::vector<std::pair<std::string, std::string>>& properties);
    void generateIdRule(const std::string& idName, const std::vector<std::pair<std::string, std::string>>& properties);
    void beginInlineStyleBlock();
    void endInlineStyleBlock();
    void generatePseudoRule(const std::string& pseudo, const std::vector<std::pair<std::string, std::string>>& properties);
    
    // 注释处理
    void generateComment(const std::string& comment, bool isGeneratorComment = false);
    void processSingleLineComment(const std::string& comment);
    void processMultiLineComment(const std::string& comment);
    void processGeneratorComment(const std::string& comment);
    
    // 自动化功能
    void autoAddClass(const std::string& className);
    void autoAddId(const std::string& idName);
    std::string getCurrentElementClass() const;
    std::string getCurrentElementId() const;
    
    // 上下文推导
    std::string resolveContextSelector(const std::string& selector);
    bool hasAutoGeneratedClass() const;
    bool hasAutoGeneratedId() const;
    
    // 输出获取
    std::string getHTML() const { return htmlOutput.str(); }
    std::string getCSS() const { return cssOutput.str(); }
    std::string getJS() const;
    std::string getCombinedOutput() const;
    
    // 重置
    void reset();

    // 原始内容生成
    void generateRawContent(const std::string& content);
    
    // 原始嵌入处理
    void processOriginBlock(const std::string& declaration, const std::string& content);
    void useOriginBlock(const std::string& name);
    
    // 导入处理
    void processImportStatement(const std::string& statement);
    void processImports(const std::vector<std::string>& statements);
    void configureImportPaths(const ImportPathConfig& config);
    
    // 命名空间处理
    void beginNamespace(const std::string& name);
    void endNamespace();
    void processNamespaceDeclaration(const std::string& declaration);
    
    // 带命名空间的使用
    void useTemplateFromNamespace(const std::string& templateName, const std::string& namespacePath);
    void useCustomFromNamespace(const std::string& customName, const std::string& namespacePath);
    
    // 约束处理
    void processExceptStatement(const std::string& statement);
    void addElementConstraint(const std::string& elementPath, const std::string& exceptClause);
    void addNamespaceConstraint(const std::string& namespacePath, const std::string& exceptClause);
    bool checkConstraint(const std::string& usage);

    // 脚本处理
    void beginScriptBlock();
    void endScriptBlock();
    void addScriptContent(const std::string& content);
    void processLocalScript(const std::string& script);

    // 处理全局样式块
    void processGlobalStyleBlock(const std::string& cssContent);

    // 处理全局脚本块
    void processGlobalScriptBlock(const std::string& jsContent, const std::string& type = "text/javascript");
};

// 字面量处理器
class LiteralProcessor {
public:
    // 检查是否是无修饰字面量
    static bool isUnquotedLiteral(const std::string& value);
    
    // 检查是否有引号
    static bool hasQuotes(const std::string& value);
    
    // 移除引号
    static std::string removeQuotes(const std::string& value);
    
    // 转义HTML特殊字符
    static std::string escapeHTML(const std::string& value);
    
    // 处理CSS值
    static std::string processCSSValue(const std::string& value);
};

// 样式提取器
class StyleExtractor {
private:
    std::vector<StyleRule> extractedRules;
    std::unordered_set<std::string> processedSelectors;
    
public:
    // 提取非内联样式
    void extractNonInlineStyles(const std::vector<StyleRule>& rules);
    
    // 检查是否应该提取到全局
    bool shouldExtractToGlobal(const std::string& selector) const;
    
    // 获取提取的规则
    const std::vector<StyleRule>& getExtractedRules() const { return extractedRules; }
    
    // 生成全局样式块
    std::string generateGlobalStyleBlock() const;
};

// 注释处理器
class CommentProcessor {
public:
    // 解析注释类型
    enum class CommentType {
        SINGLE_LINE,      // //
        MULTI_LINE,       // /* */
        GENERATOR         // --
    };
    
    // 检测注释类型
    static CommentType detectCommentType(const std::string& text);
    
    // 提取注释内容
    static std::string extractCommentContent(const std::string& text, CommentType type);
    
    // 格式化为HTML注释
    static std::string formatAsHTMLComment(const std::string& content);
};

} // namespace chtl

#endif // CHTL_GENERATOR_H