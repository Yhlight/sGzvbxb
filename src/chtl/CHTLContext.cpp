// CHTLContext.cpp - CHTL编译上下文实现
#include "CHTLContext.h"
#include <sstream>
#include <algorithm>
#include <iostream>

namespace chtl {

// 前向声明辅助函数
void registerBuiltinSymbols(CHTLContext* ctx);

CHTLContext::CHTLContext() 
    : stateMachine(std::make_unique<CHTLStateMachine>()),
      globalScope(std::make_shared<Scope>(ScopeType::GLOBAL, "global")),
      currentFile("unknown"),
      currentLine(1) {
    
    // 初始化全局作用域
    scopeStack.push(globalScope);
    
    // 初始化配置
    config.defaultEncoding = "UTF-8";
    config.defaultOutput = "output.html";
    config.generateSourceMap = false;
    config.minifyOutput = false;
    config.optimizationLevel = 1;
    
    // 注册内置符号
    registerBuiltinSymbols(this);
}

void CHTLContext::pushScope(ScopeType type, const std::string& name) {
    auto newScope = std::make_shared<Scope>(type, name, scopeStack.top());
    scopeStack.push(newScope);
}

void CHTLContext::popScope() {
    if (scopeStack.size() > 1) {  // 保留全局作用域
        scopeStack.pop();
    }
}

std::shared_ptr<Scope> CHTLContext::getCurrentScope() const {
    return scopeStack.top();
}

bool CHTLContext::registerSymbol(const std::string& name, SymbolType type, std::shared_ptr<void> definition) {
    auto symbol = std::make_shared<Symbol>(name, type);
    symbol->definition = definition;
    symbol->source_file = currentFile;
    symbol->line_number = currentLine;
    
    auto scope = getCurrentScope();
    bool added = scope->addSymbol(symbol);
    
    // 如果是全局作用域，同时加入快速查找表
    if (added && scope->getType() == ScopeType::GLOBAL) {
        globalSymbols[name] = symbol;
    }
    
    return added;
}

std::shared_ptr<Symbol> CHTLContext::lookupSymbol(const std::string& name) {
    auto scope = getCurrentScope();
    return scope->lookupSymbolRecursive(name);
}

std::shared_ptr<Symbol> CHTLContext::lookupSymbolWithNamespace(const std::string& name, const std::string& ns) {
    // 简单实现：先查找名称空间，再查找符号
    if (!ns.empty()) {
        auto nsSymbol = lookupSymbol(ns);
        if (nsSymbol && nsSymbol->type == SymbolType::NAMESPACE) {
            // 构造完整的符号名称：namespace::symbol
            std::string fullName = ns + "::" + name;
            
            // 首先尝试查找完整名称
            auto fullSymbol = lookupSymbol(fullName);
            if (fullSymbol) {
                return fullSymbol;
            }
            
            // 如果没找到，创建一个引用符号
            auto refSymbol = std::make_shared<Symbol>(fullName, SymbolType::ELEMENT);
            refSymbol->source_file = nsSymbol->source_file;
            refSymbol->namespace_name = ns;
            return refSymbol;
        }
    }
    return lookupSymbol(name);
}

void CHTLContext::addImport(const std::string& path, const std::string& alias) {
    imports[alias.empty() ? path : alias] = path;
}

bool CHTLContext::isImported(const std::string& name) const {
    return imports.find(name) != imports.end();
}

void CHTLContext::setConfigValue(const std::string& key, const std::string& value) {
    // 根据key设置对应的配置项
    if (key == "encoding") {
        config.defaultEncoding = value;
    } else if (key == "output") {
        config.defaultOutput = value;
    } else if (key == "sourceMap") {
        config.generateSourceMap = (value == "true");
    } else if (key == "minify") {
        config.minifyOutput = (value == "true");
    } else if (key == "optimization") {
        config.optimizationLevel = std::stoi(value);
    }
}

bool CHTLContext::checkConstraints(const std::string& feature) const {
    // 检查当前作用域的约束
    auto scope = scopeStack.top();
    return scope->isAllowed(feature);
}

void CHTLContext::addConstraint(const std::string& constraint) {
    // 向当前作用域添加约束
    auto scope = scopeStack.top();
    scope->addConstraint(constraint);
}

std::string CHTLContext::generateAutoClassName(const std::string& base) {
    int& counter = autoGeneratedNames[base + "_class"];
    counter++;
    return base + "_" + std::to_string(counter);
}

std::string CHTLContext::generateAutoId(const std::string& base) {
    int& counter = autoGeneratedNames[base + "_id"];
    counter++;
    return base + "_" + std::to_string(counter);
}

void CHTLContext::reportError(const std::string& message) {
    std::stringstream ss;
    ss << "Error in " << currentFile << ":" << currentLine << " - " << message;
    // 这里应该抛出异常或记录到错误管理器
    throw std::runtime_error(ss.str());
}

void CHTLContext::reportWarning(const std::string& message) {
    std::stringstream ss;
    ss << "Warning in " << currentFile << ":" << currentLine << " - " << message;
    // 这里应该记录到警告列表
    // 暂时输出到标准错误
    std::cerr << ss.str() << std::endl;
}

bool CHTLContext::validate() const {
    // 验证作用域栈是否正确（应该只剩下全局作用域）
    if (scopeStack.size() != 1) {
        return false;
    }
    
    return true;
}

void CHTLContext::reset() {
    // 清空作用域栈，保留全局作用域
    while (scopeStack.size() > 1) {
        scopeStack.pop();
    }
    
    // 重置其他状态
    globalSymbols.clear();
    imports.clear();
    autoGeneratedNames.clear();
    currentLine = 1;
    currentFile = "unknown";
    
    // 重新注册内置符号
    registerBuiltinSymbols(this);
}

// 注册内置符号的辅助函数
void registerBuiltinSymbols(CHTLContext* ctx) {
    // 注册内置HTML标签
    std::vector<std::string> builtinTags = {
        "html", "head", "body", "div", "span", "p", "a", "img",
        "h1", "h2", "h3", "h4", "h5", "h6",
        "ul", "ol", "li", "table", "tr", "td", "th",
        "form", "input", "button", "select", "option", "textarea",
        "header", "footer", "nav", "main", "article", "section"
    };
    
    for (const auto& tag : builtinTags) {
        ctx->registerSymbol(tag, SymbolType::ELEMENT);
    }
    
    // 注册内置函数
    std::vector<std::string> builtinFunctions = {
        "text", "style", "script", "import", "include"
    };
    
    for (const auto& func : builtinFunctions) {
        ctx->registerSymbol(func, SymbolType::ELEMENT);  // 暂时用ELEMENT代替FUNCTION
    }
}

} // namespace chtl